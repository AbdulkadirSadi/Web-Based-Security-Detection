using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.ML;
using Microsoft.ML.Data;
using MLSecurityScanner.Models;

namespace MLSecurityScanner.Services
{
    public class MalwareClassifier
    {
        private readonly MLContext _mlContext;
        private ITransformer? _trainedModel;
        private string _modelPath;

        public MalwareClassifier(string modelPath = "MalwareModel.zip")
        {
            _mlContext = new MLContext(seed: 1);
            _modelPath = modelPath;
        }

        public void TrainModel(IEnumerable<ScanResultModel> data)
        {
            // Veriyi FileData formatına dönüştür
            var trainingData = data.ToFileDataList().ToList();

            // Veriyi IDataView'a dönüştür
            IDataView trainingDataView = _mlContext.Data.LoadFromEnumerable(trainingData);

            // 80% eğitim, 20% test için veriyi ayır
            var dataSplit = _mlContext.Data.TrainTestSplit(trainingDataView, testFraction: 0.2);

            // Veri işleme ve model pipeline'ı oluştur
            var pipeline = _mlContext.Transforms.Concatenate("Features", new[]
                {
                    "FileSize", "EntropyScore", "HasValidPEHeader", "SuspiciousAPICount",
                    "StringEntropyValue", "SuspiciousStringCount", "ObfuscatedCodeRatio",
                    "HasValidSignature", "ExecutableCodeRatio", "CompressionRatio",
                    "EncryptedSectionRatio", "VirusTotalDetectionRatio"
                })
                .Append(_mlContext.Transforms.NormalizeMinMax("Features"))
                .Append(_mlContext.BinaryClassification.Trainers.FastTree(
                    numberOfLeaves: 20,
                    numberOfTrees: 100,
                    minimumExampleCountPerLeaf: 10,
                    learningRate: 0.2));

            // Modeli eğit
            _trainedModel = pipeline.Fit(dataSplit.TrainSet);

            // Modeli kaydet
            _mlContext.Model.Save(_trainedModel, dataSplit.TrainSet.Schema, _modelPath);

            // Test veri seti üzerinde model performansını değerlendir
            var predictions = _trainedModel.Transform(dataSplit.TestSet);
            var metrics = _mlContext.BinaryClassification.Evaluate(predictions);

            // Performans metriklerini göster
            Console.WriteLine($"Accuracy: {metrics.Accuracy:F4}");
            Console.WriteLine($"AUC: {metrics.AreaUnderRocCurve:F4}");
            Console.WriteLine($"F1 Score: {metrics.F1Score:F4}");
            Console.WriteLine($"Precision: {metrics.PositivePrecision:F4}");
            Console.WriteLine($"Recall: {metrics.PositiveRecall:F4}");
        }

        public MalwarePrediction PredictSample(ScanResultModel scanResult)
        {
            // Model yüklenmemişse, yükle
            if (_trainedModel == null)
            {
                if (File.Exists(_modelPath))
                {
                    _trainedModel = _mlContext.Model.Load(_modelPath, out _);
                }
                else
                {
                    throw new FileNotFoundException($"Model file not found: {_modelPath}. Please train the model first.");
                }
            }

            // ScanResultModel'i FileData'ya dönüştür
            var sampleData = scanResult.ToFileData();

            // Tahmin yap
            var predictionEngine = _mlContext.Model.CreatePredictionEngine<FileData, MalwarePrediction>(_trainedModel);
            return predictionEngine.Predict(sampleData);
        }

        public ModelMetrics EvaluateModel(IEnumerable<ScanResultModel> testData)
        {
            // Model yüklenmemişse, yükle
            if (_trainedModel == null)
            {
                if (File.Exists(_modelPath))
                {
                    _trainedModel = _mlContext.Model.Load(_modelPath, out _);
                }
                else
                {
                    throw new FileNotFoundException($"Model file not found: {_modelPath}. Please train the model first.");
                }
            }

            // Test verilerini FileData formatına dönüştür
            var testSamples = testData.ToFileDataList().ToList();

            // Veriyi IDataView'a dönüştür
            IDataView testDataView = _mlContext.Data.LoadFromEnumerable(testSamples);

            // Modeli değerlendir
            var predictions = _trainedModel.Transform(testDataView);
            var metrics = _mlContext.BinaryClassification.Evaluate(predictions);

            // ConfusionMatrix nesnesi oluştur
            var cm = new ConfusionMatrix();
            
            // Karmaşıklık matrisini hesapla (basit yaklaşım)
            float threshold = 0.5f;
            int truePositives = 0, trueNegatives = 0, falsePositives = 0, falseNegatives = 0;
            
            var predictedLabels = _mlContext.Data.CreateEnumerable<MalwarePrediction>(predictions, false);
            var actualLabels = testSamples.Select(x => x.IsMalware);
            
            using (var enumerator = predictedLabels.GetEnumerator())
            {
                int i = 0;
                while (enumerator.MoveNext() && i < actualLabels.Count())
                {
                    bool predicted = enumerator.Current.Probability > threshold;
                    bool actual = actualLabels.ElementAt(i);
                    
                    if (predicted && actual) truePositives++;
                    else if (!predicted && !actual) trueNegatives++;
                    else if (predicted && !actual) falsePositives++;
                    else if (!predicted && actual) falseNegatives++;
                    
                    i++;
                }
            }
            
            cm.TruePositives = truePositives;
            cm.TrueNegatives = trueNegatives;
            cm.FalsePositives = falsePositives;
            cm.FalseNegatives = falseNegatives;

            return new ModelMetrics
            {
                Accuracy = metrics.Accuracy,
                AreaUnderRocCurve = metrics.AreaUnderRocCurve,
                F1Score = metrics.F1Score,
                PositivePrecision = metrics.PositivePrecision,
                PositiveRecall = metrics.PositiveRecall,
                ConfusionMatrix = cm
            };
        }
    }

    public class ModelMetrics
    {
        public double Accuracy { get; set; }
        public double AreaUnderRocCurve { get; set; }
        public double F1Score { get; set; }
        public double PositivePrecision { get; set; }
        public double PositiveRecall { get; set; }
        public required ConfusionMatrix ConfusionMatrix { get; set; }
    }

    public class ConfusionMatrix
    {
        public long TruePositives { get; set; }
        public long TrueNegatives { get; set; }
        public long FalsePositives { get; set; }
        public long FalseNegatives { get; set; }
    }
} 